### 用处

- 通过提供组件的任务流管理器，定向更新组件内容
- 减少重复渲染
- 避免任务重复执行
- 避免由于请求返回时间的不确定性，导致展示数据出现问题
- 记录所有当前节点的运行状态，避免用户进行过多无用的操作

### 如何使用

### feature

- taskItem 组件更新
- 循环依赖的调度(保证运行时不成闭环)
- 阻塞第一次渲染，渲染统一由 context 管控

### 2.x 功能迭代

- 在 1.0 的版本基础上，新增调度中心的概念，调度中心可以统一管理默认值的数据，并检查是否要发起新的请求
- 通过 forceUpdate & shouldComponentUpdate 的组合方式强管控下层组件的渲染逻辑，
- ReactFieldContext 新增了两个新的参数， value & state， 并新增了两个校验方法，用来对每一个调度是否触发进行判断
- immer 变为必须的依赖，通过 immer 可以很好的通过 shallowEqual 的方式校验调度的更新

### 功能设计

- context 共享中心
  - 状态
  - 任务信息
  - 节点数据
  - 节点状态
    - 节点当前运行装填
    - 节点运行失败的错误信息
    - cancelMap 取消队列
  - Action
    - 新增
    - 更新
    - 删除
- 任务调度中心
  - 单个任务执行 单个组件内部数据发生改变
  - 多任务执行 共享中心派发
  - dfs 任务执行 初始化任务执行
- 生命周期
  - 初始化阶段
    - init 初始化
    - beforeExecute
    - execute
    - onPreChange
    - onChange
    - onError
  - 更新阶段
    - 更新阶段初始化状态
    - beforeExecute
    - execute
    - onPreChange
    - onChange
    - onError
  - taskInfo 更新
  - addTask
    新增的任务节点，会触发任务的节点的任务执行
  - removeTask
    移除任务节点，会触发所有依赖此节点的任务重新执行
  - 刷新
- 群组任务(分为两个状态： 控制下游群组的状态 | 不控制下游群组的状态)
  - 下游节点状态更新
  - 下游节点状态不更新

### 问题

当新增节点的时候，后续新增的节点的 dispatch 状态会晚于 useEffect

### 冒烟逻辑测试

1. 任务调度是否正常执行， 调度状态是否正常
2. 组件接受的数据是否和 state 中的数据状态保持一致
3. 任务新增是否用重新刷新
4. 组件移除，依赖组件是否刷新
5. 任务属性更新是否会刷新
6. 任务是否按照依赖关系正常执行



## 3.0版本
1. 管理模块状态，并支持组件间共享状态
2. 获取依赖的组件的状态
3. 模块状态改变了，通知所有的下游响应式函数进行执行
4. 修改模块状态

- 视图渲染，脏检测机制
- 状态更新批处理机制
- 依赖包的缩减

#### 思考
1. 响应式函数、状态组件、管道
2. reset一个compute， 用户需要感知到上层是在执行reset
3. (局部状态怎么融合， 怎么合并)[https://img.alicdn.com/tfs/TB1TAoIh_M11u4jSZPxXXahcXXa-974-520.png]
  - 可以通过定义新的rdxNode类型来达到目的
4. 和reducer怎么融合
  - 可以通过定义新的rdxNode类型来达到目的
5. 检测到环的方式怎么处理

### 依赖收集
- 声明式收集
- 自动化收集
  - mobx
  - vue
  - recoil
  - concent
  - https://github.com/nx-js/observer-util?spm=ata.13261165.0.0.367462b4wTnzlR
  - https://github.com/alloc/wana?spm=ata.13261165.0.0.367462b4wTnzlR



### TODO
- (废弃)~~useRdxReaction 支持id和rdxNode两种类型作为依赖条件~~
- utils waitForNone（立即返回加载器）, waitForAll(等待所有依赖执行完成后返回), waitForAny(至少一个依赖更新了), noWait调研
- (完成)selctorFamily, (暂时没有场景)atomFamily 设计
- (待开发)scope and weight 如何接入？
- (待开发)环检测后事件流逻辑是否有控制的必要，针对环情况的优化
- (开发中)如何结合表单场景, 流的思路 和 常规代码思路结合
- 状态管理流的状态分析
- (重要·)设置数据时的依赖环检测策略
  - 目前暂时没有很好的检测策略
- 控制onChange回调的时机

### 冒烟逻辑测试
1. atom， compute， reaction 单独的用例
2. reaction、compute使用atom，的get 链路
3. reaction、compute使用atom，的set 链路 和reset链路

### 理论依据
1. 主观输入(用户主动触发的场景)
2. 所有触发任务执行了一次(保证页面是最新的状态触发的)
问题： 

### 事件流使用情况分析
1. 本地状态共享
2. 远程状态获取&共享
3. 动态入参的方式获取组件状态(可以使用外部的参数，还可以使用其他节点的共享数据)
4. 动态入参的方式生成组件观察的状态

### 已知问题
- (完成)selector中的依赖，如果是异步的情况，没有办法识别出来， 因为通过调用该方法的方式识别依赖的，而不是等这个方法执行完成之后识别依赖的。 
  解决方案： 异步依赖有两种情况，
  一种是被观察这比观察者捕获依赖的顺序要快，这个时候不需要额外的处理，因为依赖检测可以在被观察者数据生成之前完成
  第二种是被观察者比观察者执行的要慢，那么观察者显然会先执行完，这个时候可以捕获到依赖，但是结果值不可以信任，需要重新获取这次的数据，并停止之前的依赖

- (完成)compute的值是一个虚拟的属性，不应该存储在全局的store中
- (完成)rdxstore的数据如何序列化，并在下次使用，rdxstore应该是一个完全非受控的状态，只应该有默认的state设置，不应该有value和onChange
- (完成)可以构造一个操作符，可以观察全局节点的执行情况，这样可以方便表单实现数据预览状态，也可以提供给提交的组件一个获取全局数据的机会
- 作用域的概念该怎么来营造，因为并不是所有东西都是立即执行，思路1： 可以通过另外一个rdx来构造
- (废弃)初始化设置默认值的代码有问题，需要考虑受控和非受控情况的区别
- onChange的正确触发时机。默认值初始化的过程，不一定执行了调度，怎么监控这种情况
  - 1. 任务执行完成
  - 2. 任务初始化的时候 addOrUpdateTask
  - 3. 数据变更的时候，如果没有下游任务，则触发，如果有则等待下游任务触发。

- (完成)造一个监听所有数据的Compute
- atom原子设置数据时的问题， 设置数据也可能是闭环，
- (改造后的)状态管理和分析

### 添加测试能力遇到的问题
1. 首先为了支持ts的测试用例，使用ts-jest
2. 需要增加moduleNameMapper映射，否则ts path的映射没有用
3. 了解测试库react-test-renderer 和@testing-library/react˛¸ 



### 修复bug
1. deps比较导致的bug，发现deps一直在变化，最终排查是通过对象比较的，而每次对象都是新创建的，所以是有问题的。
   - 发现bug的时机
      表格新增一个的Error校验，一直在重复触发
2. scheduleCore的问题
  - 问题1： 发现起始节点可能被忽略，原因是起始节点的入度为0，执行方式是先序遍历，先序遍历中重新触发了任务流，导致为0的节点被忽略，
  通过执行开始节点前，将开始节点的入度置为1，执行完成后置为0的方式解决， 通过入度表来唯一表示节点是否执行完成
  - 问题2： 当scheduleTask更新的时候，发现依赖节点已经脏了，那么scheduleTask需要终止，终止的时候发现入度表中并没有出现该节点，也就是这个时候
  该节点的所有上游都执行完成了，导致改节点的任务无故消失了，通过判断如果入度表中没有该节点，并加入的方式修复了。 
3. RdxStore的问题
  - 当任务执行失败后，检测到依赖变化，这个时候通过executeTask去触发任务重新执行，但是这个时候这个节点应该不可以复用了，但是没有将节点标记为脏节点，导致节点的任务执行复用了，所以无法正常执行下去
### 有趣的问题
- useEffect 和 promise 执行，谁更快
  - 因为可以订阅同步任务，也可以订阅异步任务，所以在useEffect中开始订阅的话，很可能会出现消息缺漏现象
- 如何使用React的batch能力，这个目前有点问题，会抛warning
- 任务如何复用
- 同步任务和异步任务如何区分？
- 先执行调度，还是先执行依赖---核心要保证调度顺序优先
- 如何利用promise来进行任务串行执行，当任务fork的时候怎么处理，新的数据流和老的数据流如何复用？
- 加载任务，依赖更新，任务调度执行都会触发get方法执行，如何尽可能少的触发，
  1. 利用cache数据 2. 重新检测数据 3.确实还有问题就抛异常
  - 场景1： 依赖检测第一个就失败， 依赖更新的时候会触发检测
- 环检测算法
- 如何声明一个唯一的状态，创建一个对象，通过对象的引用唯一来表示
- 浏览器插件 devtool
- 如何降低寻找下游点的复杂度？



### 待探索方向
- 当依赖任务没有加载完成的情况， 能否不重新更新依赖，而直接等待任务执行完成吗，否则业务代码会重复执行很多次。
  要建立一个断点重启的机制，这个机制只能用在async的情况下，当依赖找不到的时候，get方法需要返回一个Promise，然后等待任务执行完成后来触发执行。